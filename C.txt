@@ extern的用法
## <1> 在源文件a中定义变量p，如果在源文件b中也定义变量b，同时编译会有什么结果
<2> 在源文件a中定义变量p，在源文件b中定义变量extern p，同时编译
<3> 在源文件a中定义变量P，在源文件b中直接调用（未声明）
<4> 在源文件啊中声明extern p，在源文件b中声明extern p
结论：在源文件a和源文件b中分别定义p会导致，多重定义；在源文件a中定义p，在源文件b中直接调用会出现未定义；在源文件a中定义p，在源文件b中声明extern p可以通过
在源文件b中定义函数print(),在源文件a中要么include 头文件，要么声明为extern print(),否则不能调用print();
不能在源文件a中和b中全部声明成extern p，会导致没有定义p。

@@ switch 语句是否接受字符串
## 不能，switch 只接受整形

@@ szeof(a=b+1),a的值没有被修改，得出的结果是a的长度？
## 得出的是a的类型长度，a的值没有被修改

@@ 两个指针只有在指向同一个数组中的元素才能相减，如果不是指向同一个数组元素？
## 语法可以通过但是无意义

@@ 字符串结尾的字符是什么
## NUL 即 '\0'

@@ printf 打印 十进制整型，八进制整型，十六进制整型，浮点值，字符，字符串分别是什么
## %d,%o,%x,%g,%c,%s

@@ scanf 读取一个整型，长整形，浮点型，双精度浮点，字符，字符串，的格式
## %d,%ld,%f,%lf,%c,%s

@@ 十六进制，八进制表示方法
## 八进制前加0，十六进制前加0x

@@ 声明枚举类型，声明枚举变量
## enum name {A,B,C,D...};   name enum1,enum2; 或 enum name {0,1,2,3...}enum1,enum2;

$$ char 类型默认可能是 signed char 也可能是 unsigned char，因编译器而异

@@ 用typedef定义一个指针类型的名字
## typedef type *newname; newname是一个指向type类型的指针

$$ 浮点类型不可用signed,unsigned

@@ 存储变量的三个地方
## 普通内存，运行时堆栈，寄存器，在代码块之外声明的变量存在静态内存中(普通内存)

@@ 按位与，或，异或，求反的符号
## &,|,^,~

@@ 逗号操作符的执行顺序，表达式的值
## 自左向右执行，表达式的值是最右边的值

$$ 运算符优先级

$$ 指针初始化的错误方式 int *a; *a = 1; 正确方式 : int *a = &b;

$$ sizeof()一个数组，返回的是整个数组的字节数

@@ 用字符数组初始化一个字符串
## char a[] = {'h','e','l','l','o',0}; 或{.....,'\0'};

@@ 三维数组 char a[2][3][4];的意义
## 数组有三层，第一层有两个元素，存着指向一个二维数组[3][4]的指针，第二层有三个元素，存着指向一个一维数组[4]的指针，第三层有四个元素，分别存着char

@@ 定义一个指向数组的指针
## int (*a)[10];

@@ 结构体的自引用如何声明
## struct A {struct A* a;}

@@ 声明一个函数指针
## int (*f)(int,int);

@@ 声明一个函数指针的类型
## typedef int (*typename)(int,int);

@@ 字符串常量的特殊用法
## "abcde"[2] 表达式结果为c

@@ 宏定义表达式的用法
## #define MAX(a,b) ((a)>(b)?(a):(b))

@@ 将宏的参数转换字符串
## #define PRINT(a) printf("print" #a)

@@ 在头文件中定义函数为什么一定要是 static
## 如果不定义成static且两个源文件包含了同一个头文件，会导致重定义

@@realloc();
##空间足或不足都会返回一个指针，并且自动释放原指针，返回地址可能和原地址相同，切记不用再free

@@ 两个指针相减的结果
## 结果是地址的差/指针类型大小